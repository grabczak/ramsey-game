{"version":3,"sources":["serviceWorker.ts","redux/reducers/game.ts","redux/store.ts","constants/actions.ts","components/Node/index.tsx","redux/actions/game.ts","components/Graph/index.tsx","components/Form/index.tsx","index.tsx","components/App/index.tsx"],"names":["Boolean","window","location","hostname","match","createGraph","size","nodes","edges","i","push","id","j","source","target","team","initialState","targetCliqueSize","isGameRunning","whoIsMoving","winner","rootReducer","combineReducers","game","state","action","type","payload","Math","min","length","map","edge","filter","item","logger","createLogger","collapsed","store","createStore","applyMiddleware","thunk","Node","className","jsnx","require","endGame","nextMove","Graph","useSelector","dispatch","useDispatch","jsnxNodes","useMemo","node","String","random","x","cos","PI","y","sin","jsnxEdges","find","floor","Number","color","graph","links","data","config","viewGenerator","renderLabel","link","strokeWidth","staticGraph","width","height","onClickLink","numberSource","numberTarget","getState","a","jsnxPlayerEdges","jsnxComputerEdges","availableEdges","playerGraph","addNodesFrom","addEdgesFrom","graphCliqueNumber","computerGraph","isAvailable","some","newEdge","b","newComputerGraph","addEdge","winningEdge","newPlayerGraph","jsnxPDegrees","degree","playerDegrees","Array","from","sort","jsnxCDegrees","computerDegrees","v1","v2","availableEdgesWithPlayerVertex","computerDegree","playerDegree","findNewEdge","playerMove","Form","graphSize","useEffect","loading","document","getElementById","interval","setInterval","innerHTML","clearInterval","value","onChange","e","disabled","max","onClick","style","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.587dcbd3.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import {\n  SET_GRAPH_SIZE,\n  SET_TARGET_CLIQUE_SIZE,\n  START_GAME,\n  END_GAME,\n  NEXT_MOVE,\n} from '../../constants/actions';\nimport { TGameAction } from '../../typings/actions';\nimport { TGameState } from '../../typings/state';\n\nconst createGraph = (size: number) => {\n  const nodes = [];\n  const edges = [];\n\n  for (let i = 0; i < size; i++) {\n    nodes.push({ id: i });\n  }\n\n  for (let i = 0; i < size; i++) {\n    for (let j = i + 1; j < size; j++) {\n      edges.push({\n        source: nodes[i].id,\n        target: nodes[j].id,\n        team: null,\n      });\n    }\n  }\n\n  return {\n    nodes,\n    edges,\n  };\n};\n\nconst initialState = {\n  ...createGraph(10),\n  targetCliqueSize: 4,\n  isGameRunning: false,\n  whoIsMoving: 'player' as const,\n  winner: null,\n};\n\nexport const game = (state: TGameState = initialState, action: TGameAction) => {\n  switch (action.type) {\n    case SET_GRAPH_SIZE:\n      return {\n        ...state,\n        ...createGraph(action.payload.size),\n        targetCliqueSize: Math.min(state.targetCliqueSize, action.payload.size),\n        whoIsMoving: 'player',\n        winner: null,\n      };\n    case SET_TARGET_CLIQUE_SIZE:\n      return {\n        ...state,\n        ...createGraph(state.nodes.length),\n        targetCliqueSize: action.payload.size,\n        whoIsMoving: 'player',\n        winner: null,\n      };\n    case START_GAME:\n      return {\n        ...state,\n        edges: state.edges.map((edge) => ({\n          ...edge,\n          team: null,\n        })),\n        isGameRunning: true,\n        whoIsMoving: 'player',\n        winner: null,\n      };\n    case END_GAME:\n      return {\n        ...state,\n        edges: action.payload.winner\n          ? state.edges\n          : state.edges.map((edge) => ({\n              ...edge,\n              team: null,\n            })),\n        isGameRunning: false,\n        winner: action.payload.winner,\n      };\n    case NEXT_MOVE:\n      return {\n        ...state,\n        edges: [\n          ...state.edges.filter(\n            (item) =>\n              item.source !== action.payload.edge.source ||\n              item.target !== action.payload.edge.target,\n          ),\n          action.payload.edge,\n        ],\n        whoIsMoving:\n          action.payload.edge.team === 'player' ? 'computer' : 'player',\n      };\n    default:\n      return state;\n  }\n};\n","import { combineReducers, createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport { createLogger } from 'redux-logger';\n\nimport { game } from './reducers/game';\n\nconst rootReducer = combineReducers({ game });\n\nconst logger = createLogger({\n  collapsed: true,\n});\n\nexport const store = createStore(rootReducer, applyMiddleware(thunk, logger));\n","export const SET_GRAPH_SIZE = 'SET_GRAPH_SIZE';\nexport const SET_TARGET_CLIQUE_SIZE = 'SET_TARGET_CLIQUE_SIZE';\nexport const START_GAME = 'START_GAME';\nexport const END_GAME = 'END_GAME';\nexport const NEXT_MOVE = 'NEXT_MOVE';\n","import React from 'react';\nimport './styles.css';\n\nexport type TNodeProps = {\n  id: number;\n};\n\nexport const Node = ({ id }: TNodeProps) => {\n  return (\n    <div className=\"node\">\n      <p>{id + 1}</p>\n    </div>\n  );\n};\n","import {\n  SET_GRAPH_SIZE,\n  SET_TARGET_CLIQUE_SIZE,\n  START_GAME,\n  END_GAME,\n  NEXT_MOVE,\n} from '../../constants/actions';\nimport { TNode, TEdge, TRootState } from '../../typings/state';\nimport { wait } from '../../utils/wait';\n\nconst jsnx = require('jsnetworkx');\n\nexport const setGraphSize = (size: number) => {\n  return {\n    type: SET_GRAPH_SIZE,\n    payload: { size },\n  };\n};\n\nexport const setTargetCliqueSize = (size: number) => {\n  return {\n    type: SET_TARGET_CLIQUE_SIZE,\n    payload: { size },\n  };\n};\n\nexport const startGame = () => {\n  return {\n    type: START_GAME,\n  };\n};\n\nexport const endGame = (\n  winner: 'player' | 'computer' | 'draw' | null = null,\n) => {\n  return {\n    type: END_GAME,\n    payload: { winner },\n  };\n};\n\nexport const nextMove = (edge: TEdge) => {\n  return {\n    type: NEXT_MOVE,\n    payload: { edge },\n  };\n};\n\nexport const playerMove = (source: number, target: number) => {\n  return async (dispatch: any, getState: () => TRootState) => {\n    const { targetCliqueSize } = getState().game;\n\n    dispatch(nextMove({ source, target, team: 'player' }));\n\n    const jsnxNodes = getState().game.nodes.map((node: TNode) => node.id);\n    const jsnxPlayerEdges = getState()\n      .game.edges.filter((edge: TEdge) => edge.team === 'player')\n      .map((edge: TEdge) => [edge.source, edge.target]);\n    const jsnxComputerEdges = getState()\n      .game.edges.filter((edge: TEdge) => edge.team === 'computer')\n      .map((edge: TEdge) => [edge.source, edge.target]);\n\n    const availableEdges = getState().game.edges.filter(\n      (edge: TEdge) => edge.team === null,\n    );\n\n    const playerGraph = new jsnx.Graph();\n    playerGraph.addNodesFrom(jsnxNodes);\n    playerGraph.addEdgesFrom(jsnxPlayerEdges);\n\n    if (jsnx.graphCliqueNumber(playerGraph) === targetCliqueSize) {\n      dispatch(endGame('player'));\n      return;\n    }\n\n    const computerGraph = new jsnx.Graph();\n    computerGraph.addNodesFrom(jsnxNodes);\n    computerGraph.addEdgesFrom(jsnxComputerEdges);\n\n    const isAvailable = (source: number, target: number) => {\n      return availableEdges.some(\n        (edge: TEdge) => edge.source === source && edge.target === target,\n      );\n    };\n\n    const findNewEdge = (): TEdge & { winningEdge: boolean } => {\n      for (const a of jsnxNodes) {\n        for (const b of jsnxNodes) {\n          if (a >= b) {\n            continue;\n          }\n\n          const newComputerGraph = new jsnx.Graph();\n          newComputerGraph.addNodesFrom(jsnxNodes);\n          newComputerGraph.addEdgesFrom(jsnxComputerEdges);\n          newComputerGraph.addEdge(a, b);\n\n          if (\n            isAvailable(a, b) &&\n            jsnx.graphCliqueNumber(newComputerGraph) === targetCliqueSize\n          ) {\n            return {\n              source: a,\n              target: b,\n              team: 'computer',\n              winningEdge: true,\n            };\n          }\n        }\n      }\n\n      for (const a of jsnxNodes) {\n        for (const b of jsnxNodes) {\n          if (a >= b) {\n            continue;\n          }\n\n          const newPlayerGraph = new jsnx.Graph();\n          newPlayerGraph.addNodesFrom(jsnxNodes);\n          newPlayerGraph.addEdgesFrom(jsnxPlayerEdges);\n          newPlayerGraph.addEdge(a, b);\n\n          if (\n            isAvailable(a, b) &&\n            jsnx.graphCliqueNumber(newPlayerGraph) === targetCliqueSize\n          ) {\n            return {\n              source: a,\n              target: b,\n              team: 'computer',\n              winningEdge: false,\n            };\n          }\n        }\n      }\n\n      const jsnxPDegrees: Map<number, number> = jsnx.degree(playerGraph);\n\n      const playerDegrees: number[][] = Array.from(jsnxPDegrees).sort(\n        (a: number[], b: number[]) => a[1] - b[1],\n      );\n\n      const jsnxCDegrees: Map<number, number> = jsnx.degree(computerGraph);\n\n      const computerDegrees: number[][] = Array.from(jsnxCDegrees).sort(\n        (a: number[], b: number[]) => b[1] - a[1],\n      );\n\n      if (targetCliqueSize === 3) {\n        if (jsnxComputerEdges.length === 0) {\n          const [v1, v2] = jsnxPlayerEdges[0];\n\n          const availableEdgesWithPlayerVertex = availableEdges.filter(\n            (edge: TEdge) =>\n              edge.source === v1 ||\n              edge.source === v2 ||\n              edge.target === v1 ||\n              edge.target === v2,\n          );\n\n          const edge =\n            availableEdgesWithPlayerVertex[\n              Math.floor(Math.random() * availableEdgesWithPlayerVertex.length)\n            ];\n\n          return {\n            ...edge,\n            team: 'computer',\n            winningEdge: false,\n          };\n        }\n\n        for (const computerDegree of computerDegrees) {\n          for (const playerDegree of playerDegrees) {\n            const [v1, v2] = [computerDegree[0], playerDegree[0]].sort();\n\n            if (isAvailable(v1, v2)) {\n              return {\n                source: v1,\n                target: v2,\n                team: 'computer',\n                winningEdge: false,\n              };\n            }\n          }\n        }\n      }\n\n      if (targetCliqueSize === 4) {\n        if (jsnxComputerEdges.length === 0) {\n          return {\n            ...availableEdges[\n              Math.floor(Math.random() * availableEdges.length)\n            ],\n            team: 'computer',\n            winningEdge: false,\n          };\n        }\n\n        if (computerDegrees[0][1] < 4) {\n          for (const computerDegree of computerDegrees) {\n            for (const playerDegree of playerDegrees) {\n              const [v1, v2] = [computerDegree[0], playerDegree[0]].sort();\n\n              if (isAvailable(v1, v2)) {\n                return {\n                  source: v1,\n                  target: v2,\n                  team: 'computer',\n                  winningEdge: false,\n                };\n              }\n            }\n          }\n        }\n\n        if (jsnxComputerEdges.length === 4) {\n          for (const a of jsnxNodes) {\n            for (const b of jsnxNodes) {\n              if (a >= b) {\n                continue;\n              }\n\n              const newComputerGraph = new jsnx.Graph();\n              newComputerGraph.addNodesFrom(jsnxNodes);\n              newComputerGraph.addEdgesFrom(jsnxComputerEdges);\n              newComputerGraph.addEdge(a, b);\n\n              if (\n                isAvailable(a, b) &&\n                jsnx.graphCliqueNumber(newComputerGraph) === 3\n              ) {\n                return {\n                  source: a,\n                  target: b,\n                  team: 'computer',\n                  winningEdge: false,\n                };\n              }\n            }\n          }\n        }\n\n        for (let i = 0; i < computerDegrees.length; i++) {\n          for (let j = 0; j < computerDegrees.length; j++) {\n            if (i === 0 || j === 0) {\n              continue;\n            }\n\n            if (isAvailable(computerDegrees[i][0], computerDegrees[j][0])) {\n              return {\n                source: computerDegrees[i][0],\n                target: computerDegrees[j][0],\n                team: 'computer',\n                winningEdge: false,\n              };\n            }\n          }\n        }\n      }\n\n      return {\n        ...availableEdges[Math.floor(Math.random() * availableEdges.length)],\n        team: 'computer',\n        winningEdge: false,\n      };\n    };\n\n    const newEdge = findNewEdge();\n\n    if (newEdge.winningEdge || newEdge.source || newEdge.target) {\n      // await wait(2);\n\n      if (!getState().game.isGameRunning) {\n        return;\n      }\n\n      dispatch(nextMove(newEdge));\n\n      if (newEdge.winningEdge) {\n        dispatch(endGame('computer'));\n        return;\n      }\n    } else {\n      dispatch(endGame('draw'));\n      return;\n    }\n\n    const remainingEdges = getState().game.edges.filter(\n      (edge: TEdge) => edge.team === null,\n    );\n\n    if (remainingEdges.length === 0) {\n      dispatch(endGame('draw'));\n    }\n  };\n};\n\n// function getCycles(graph: any) {\n//   let cycles: any = [];\n\n//   function findNewCycles(graph: any, path: any) {\n//     const startNode = path[0];\n//     let nextNode = null;\n//     let sub = [];\n\n//     console.log('e');\n\n//     for (const edge of graph) {\n//       const [node1, node2] = edge;\n//       if (edge.includes(startNode)) {\n//         nextNode = node1 === startNode ? node2 : node1;\n//       }\n//       if (notVisited(nextNode, path)) {\n//         sub = [nextNode].concat(path);\n//         findNewCycles(graph, sub);\n//       } else if (path.length > 2 && nextNode === path[path.length - 1]) {\n//         const p = rotateToSmallest(path);\n//         const inv = invert(p);\n//         if (isNew(p) && isNew(inv)) {\n//           cycles.push(p);\n//         }\n//       }\n//     }\n//   }\n\n//   function invert(path: any) {\n//     return rotateToSmallest([...path].reverse());\n//   }\n\n//   function rotateToSmallest(path: any) {\n//     const n = path.indexOf(Math.min(...path));\n//     return path.slice(n).concat(path.slice(0, n));\n//   }\n\n//   function isNew(path: any) {\n//     const p = JSON.stringify(path);\n\n//     for (const cycle of cycles) {\n//       if (p === JSON.stringify(cycle)) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n\n//   function notVisited(node: any, path: any) {\n//     const n = JSON.stringify(node);\n//     for (const p of path) {\n//       if (n === JSON.stringify(p)) {\n//         return false;\n//       }\n//     }\n//     return true;\n//   }\n\n//   for (const edge of graph) {\n//     for (const node of edge) {\n//       findNewCycles(graph, [node]);\n//     }\n//   }\n\n//   return cycles;\n// }\n","import React, { useMemo } from 'react';\nimport './styles.css';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { Graph as ReactD3Graph } from 'react-d3-graph';\n\nimport { Node } from '../Node';\nimport { TRootState, TNode, TEdge } from '../../typings/state';\nimport { playerMove } from '../../redux/actions/game';\n\nexport const Graph = () => {\n  const nodes = useSelector((state: TRootState) => state.game.nodes);\n\n  const edges = useSelector((state: TRootState) => state.game.edges);\n\n  const isGameRunning = useSelector(\n    (state: TRootState) => state.game.isGameRunning,\n  );\n\n  const whoIsMoving = useSelector(\n    (state: TRootState) => state.game.whoIsMoving,\n  );\n\n  const winner = useSelector((state: TRootState) => state.game.winner);\n\n  const dispatch = useDispatch();\n\n  const onClickLink = (source: string, target: string) => {\n    const numberSource = Math.floor(Number(source));\n    const numberTarget = Math.floor(Number(target));\n\n    if (whoIsMoving === 'computer' || winner) {\n      return;\n    }\n\n    const edge = edges.find(\n      (edge: TEdge) =>\n        edge.source === numberSource && edge.target === numberTarget,\n    );\n\n    if (!edge?.team) {\n      dispatch(playerMove(numberSource, numberTarget));\n    }\n  };\n\n  const jsnxNodes = useMemo(() => {\n    return nodes.map((node: TNode) => {\n      const { length } = nodes;\n      const { id } = node;\n\n      return {\n        id: String(id + Math.random()),\n        x: 200 * Math.cos((-2 * Math.PI * id) / length + Math.PI / 2) + 250,\n        y: -200 * Math.sin((-2 * Math.PI * id) / length + Math.PI / 2) + 250,\n      };\n    });\n  }, [nodes]);\n\n  const jsnxEdges = useMemo(() => {\n    return edges.map((edge: TEdge) => {\n      return {\n        source: jsnxNodes.find(\n          ({ id }) => Math.floor(Number(id)) === edge.source,\n        )?.id,\n        target: jsnxNodes.find(\n          ({ id }) => Math.floor(Number(id)) === edge.target,\n        )?.id,\n        color:\n          edge.team === 'player'\n            ? 'green'\n            : edge.team === 'computer'\n            ? 'red'\n            : 'gray',\n      };\n    });\n  }, [jsnxNodes, edges]);\n\n  const graph = {\n    nodes: jsnxNodes,\n    links: jsnxEdges,\n  };\n\n  return (\n    <div className=\"graph\">\n      <ReactD3Graph\n        id=\"graph\"\n        data={graph}\n        config={{\n          node: {\n            viewGenerator: ({ id }: any) => (\n              <Node id={Math.floor(Number(id))} />\n            ),\n            renderLabel: false,\n          },\n          link: {\n            strokeWidth: 3,\n          },\n          staticGraph: true,\n          width: 500,\n          height: 500,\n        }}\n        onClickLink={onClickLink}\n      />\n      {!isGameRunning && <div className=\"overlay\" />}\n    </div>\n  );\n};\n","import React, { useEffect } from 'react';\nimport './styles.css';\nimport { useDispatch, useSelector } from 'react-redux';\n\nimport { TRootState } from '../../typings/state';\nimport { setGraphSize, setTargetCliqueSize } from '../../redux/actions/game';\nimport { startGame, endGame } from '../../redux/actions/game';\n\nexport const Form = () => {\n  const graphSize = useSelector((state: TRootState) => state.game.nodes.length);\n\n  const targetCliqueSize = useSelector(\n    (state: TRootState) => state.game.targetCliqueSize,\n  );\n\n  const isGameRunning = useSelector(\n    (state: TRootState) => state.game.isGameRunning,\n  );\n\n  const whoIsMoving = useSelector(\n    (state: TRootState) => state.game.whoIsMoving,\n  );\n\n  const winner = useSelector((state: TRootState) => state.game.winner);\n\n  const dispatch = useDispatch();\n\n  useEffect(() => {\n    const loading = document.getElementById('loading');\n\n    const interval = setInterval(() => {\n      if (loading) {\n        if (loading.innerHTML.length <= 2) {\n          loading.innerHTML += '.';\n        } else {\n          loading.innerHTML = '';\n        }\n      }\n    }, 500);\n\n    return () => {\n      clearInterval(interval);\n    };\n  }, [whoIsMoving]);\n\n  const handleGraphSizeChange = (e: any) => {\n    dispatch(setGraphSize(Number(e.target.value)));\n  };\n\n  const handleTargetCliqueSizeChange = (e: any) => {\n    dispatch(setTargetCliqueSize(Number(e.target.value)));\n  };\n\n  const handleGameStart = () => {\n    dispatch(startGame());\n  };\n\n  const handleGameEnd = () => {\n    dispatch(endGame());\n  };\n\n  return (\n    <div className=\"form\">\n      <div className=\"row\">\n        <p className=\"field\">Rozmiar grafu:</p>\n        <p className=\"value\">{graphSize}</p>\n        <input\n          className=\"field\"\n          type=\"range\"\n          value={graphSize}\n          onChange={handleGraphSizeChange}\n          disabled={isGameRunning}\n          min={4}\n          max={10}\n        />\n      </div>\n      <div className=\"row\">\n        <p className=\"field\">Rozmiar szukanej kliki:</p>\n        <p className=\"value\">{targetCliqueSize}</p>\n        <input\n          className=\"field\"\n          type=\"range\"\n          value={targetCliqueSize}\n          onChange={handleTargetCliqueSizeChange}\n          disabled={isGameRunning}\n          min={3}\n          max={graphSize}\n        />\n      </div>\n      <div className=\"buttonsContainer\">\n        <button\n          className=\"button\"\n          onClick={handleGameStart}\n          disabled={isGameRunning}\n        >\n          Rozpocznij grę\n        </button>\n        <button\n          className=\"button\"\n          onClick={handleGameEnd}\n          disabled={!isGameRunning}\n        >\n          Zakończ grę\n        </button>\n      </div>\n      {winner ? (\n        <p\n          className=\"loading\"\n          style={{\n            color:\n              winner === 'player'\n                ? 'green'\n                : winner === 'computer'\n                ? 'red'\n                : 'blue',\n          }}\n        >\n          {winner === 'player'\n            ? 'Człowiek wygrywa'\n            : winner === 'computer'\n            ? 'Komputer wygrywa'\n            : 'Remis'}\n        </p>\n      ) : isGameRunning ? (\n        <p className=\"loading\">\n          {whoIsMoving === 'computer' ? 'Komputer myśli' : 'Twoja kolej'}\n          {whoIsMoving === 'computer' && <span id=\"loading\" />}\n        </p>\n      ) : null}\n    </div>\n  );\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport * as serviceWorker from './serviceWorker';\n\nimport { App } from './components/App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React from 'react';\nimport './styles.css';\nimport { Provider } from 'react-redux';\n\nimport { store } from '../../redux/store';\nimport { Graph } from '../Graph';\nimport { Form } from '../Form';\n\nexport const App = () => {\n  return (\n    <Provider store={store}>\n      <div className=\"app\">\n        <h1>Gra Ramseya</h1>\n        <Form />\n        <Graph />\n      </div>\n    </Provider>\n  );\n};\n"],"sourceRoot":""}